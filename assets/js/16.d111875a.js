(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{335:function(t,a,s){t.exports=s.p+"assets/img/database-shard-method-1.877369a7.png"},336:function(t,a,s){t.exports=s.p+"assets/img/database-shard-method-2.f763a270.png"},458:function(t,a,s){"use strict";s.r(a);var _=s(11),v=Object(_.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"面试题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面试题"}},[t._v("#")]),t._v(" 面试题")]),t._v(" "),a("p",[t._v("现在有一个未分库分表的系统，未来要分库分表，如何设计才可以让系统从未分库分表"),a("strong",[t._v("动态切换")]),t._v("到分库分表上？")]),t._v(" "),a("h2",{attrs:{id:"面试官心理分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面试官心理分析"}},[t._v("#")]),t._v(" 面试官心理分析")]),t._v(" "),a("p",[t._v("你看看，你现在已经明白为啥要分库分表了，你也知道常用的分库分表中间件了，你也设计好你们如何分库分表的方案了（水平拆分、垂直拆分、分表），那问题来了，你接下来该怎么把你那个单库单表的系统给迁移到分库分表上去？")]),t._v(" "),a("p",[t._v("所以这都是一环扣一环的，就是看你有没有全流程经历过这个过程。")]),t._v(" "),a("h2",{attrs:{id:"面试题剖析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面试题剖析"}},[t._v("#")]),t._v(" 面试题剖析")]),t._v(" "),a("p",[t._v("这个其实从 low 到高大上有好几种方案，我们都玩儿过，我都给你说一下。")]),t._v(" "),a("h3",{attrs:{id:"停机迁移方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#停机迁移方案"}},[t._v("#")]),t._v(" 停机迁移方案")]),t._v(" "),a("p",[t._v("我先给你说一个最 low 的方案，就是很简单，大家伙儿凌晨 12 点开始运维，网站或者 app 挂个公告，说 0 点到早上 6 点进行运维，无法访问。")]),t._v(" "),a("p",[t._v("接着到 0 点停机，系统停掉，没有流量写入了，此时老的单库单表数据库静止了。然后你之前得写好一个"),a("strong",[t._v("导数的一次性工具")]),t._v("，此时直接跑起来，然后将单库单表的数据哗哗哗读出来，写到分库分表里面去。")]),t._v(" "),a("p",[t._v("导数完了之后，就 ok 了，修改系统的数据库连接配置啥的，包括可能代码和 SQL 也许有修改，那你就用最新的代码，然后直接启动连到新的分库分表上去。")]),t._v(" "),a("p",[t._v("验证一下，ok 了，完美，大家伸个懒腰，看看看凌晨 4 点钟的北京夜景，打个滴滴回家吧。")]),t._v(" "),a("p",[t._v("但是这个方案比较 low，谁都能干，我们来看看高大上一点的方案。")]),t._v(" "),a("p",[a("img",{attrs:{src:s(335),alt:"database-shard-method-1"}})]),t._v(" "),a("h3",{attrs:{id:"双写迁移方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#双写迁移方案"}},[t._v("#")]),t._v(" 双写迁移方案")]),t._v(" "),a("p",[t._v("这个是我们常用的一种迁移方案，比较靠谱一些，不用停机，不用看北京凌晨 4 点的风景。")]),t._v(" "),a("p",[t._v("简单来说，就是在线上系统里面，之前所有写库的地方，增删改操作，"),a("strong",[t._v("除了对老库增删改，都加上对新库的增删改")]),t._v("，这就是所谓的"),a("strong",[t._v("双写")]),t._v("，同时写俩库，老库和新库。")]),t._v(" "),a("p",[t._v("然后"),a("strong",[t._v("系统部署")]),t._v("之后，新库数据差太远，用之前说的导数工具，跑起来读老库数据写新库，写的时候要根据 gmt_modified 这类字段判断这条数据最后修改的时间，除非是读出来的数据在新库里没有，或者是比新库的数据新才会写。简单来说，就是不允许用老数据覆盖新数据。")]),t._v(" "),a("p",[t._v("导完一轮之后，有可能数据还是存在不一致，那么就程序自动做一轮校验，比对新老库每个表的每条数据，接着如果有不一样的，就针对那些不一样的，从老库读数据再次写。反复循环，直到两个库每个表的数据都完全一致为止。")]),t._v(" "),a("p",[t._v("接着当数据完全一致了，就 ok 了，基于仅仅使用分库分表的最新代码，重新部署一次，不就仅仅基于分库分表在操作了么，还没有几个小时的停机时间，很稳。所以现在基本玩儿数据迁移之类的，都是这么干的。")]),t._v(" "),a("p",[a("img",{attrs:{src:s(336),alt:"database-shard-method-2"}})])])}),[],!1,null,null,null);a.default=v.exports}}]);