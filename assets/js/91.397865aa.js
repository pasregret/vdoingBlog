(window.webpackJsonp=window.webpackJsonp||[]).push([[91],{456:function(t,r,e){"use strict";e.r(r);var i=e(11),h=Object(i.a)({},(function(){var t=this,r=t._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"高并发架构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#高并发架构"}},[t._v("#")]),t._v(" 高并发架构")]),t._v(" "),r("h2",{attrs:{id:"消息队列"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#消息队列"}},[t._v("#")]),t._v(" "),r("RouterLink",{attrs:{to:"/02.后端/high-concurrency/mq-interview.html"}},[t._v("消息队列")])],1),t._v(" "),r("ul",[r("li",[r("RouterLink",{attrs:{to:"/02.后端/high-concurrency/why-mq.html"}},[t._v("为什么使用消息队列？消息队列有什么优点和缺点？Kafka、ActiveMQ、RabbitMQ、RocketMQ 都有什么优点和缺点？")])],1),t._v(" "),r("li",[r("RouterLink",{attrs:{to:"/02.后端/high-concurrency/how-to-ensure-high-availability-of-message-queues.html"}},[t._v("如何保证消息队列的高可用？")])],1),t._v(" "),r("li",[r("RouterLink",{attrs:{to:"/02.后端/high-concurrency/how-to-ensure-that-messages-are-not-repeatedly-consumed.html"}},[t._v("如何保证消息不被重复消费？（如何保证消息消费的幂等性）")])],1),t._v(" "),r("li",[r("RouterLink",{attrs:{to:"/02.后端/high-concurrency/how-to-ensure-the-reliable-transmission-of-messages.html"}},[t._v("如何保证消息的可靠性传输？（如何处理消息丢失的问题）")])],1),t._v(" "),r("li",[r("RouterLink",{attrs:{to:"/02.后端/high-concurrency/how-to-ensure-the-order-of-messages.html"}},[t._v("如何保证消息的顺序性？")])],1),t._v(" "),r("li",[r("RouterLink",{attrs:{to:"/02.后端/high-concurrency/mq-time-delay-and-expired-failure.html"}},[t._v("如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？")])],1),t._v(" "),r("li",[r("RouterLink",{attrs:{to:"/02.后端/high-concurrency/mq-design.html"}},[t._v("如果让你写一个消息队列，该如何进行架构设计啊？说一下你的思路。")])],1)]),t._v(" "),r("h2",{attrs:{id:"搜索引擎"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#搜索引擎"}},[t._v("#")]),t._v(" "),r("RouterLink",{attrs:{to:"/02.后端/high-concurrency/es-introduction.html"}},[t._v("搜索引擎")])],1),t._v(" "),r("ul",[r("li",[r("RouterLink",{attrs:{to:"/02.后端/high-concurrency/es-architecture.html"}},[t._v("ES 的分布式架构原理能说一下么（ES 是如何实现分布式的啊）？")])],1),t._v(" "),r("li",[r("RouterLink",{attrs:{to:"/02.后端/high-concurrency/es-write-query-search.html"}},[t._v("ES 写入数据的工作原理是什么啊？ES 查询数据的工作原理是什么啊？底层的 Lucene 介绍一下呗？倒排索引了解吗？")])],1),t._v(" "),r("li",[r("RouterLink",{attrs:{to:"/02.后端/high-concurrency/es-optimizing-query-performance.html"}},[t._v("ES 在数据量很大的情况下（数十亿级别）如何提高查询效率啊？")])],1),t._v(" "),r("li",[r("RouterLink",{attrs:{to:"/02.后端/high-concurrency/es-production-cluster.html"}},[t._v("ES 生产集群的部署架构是什么？每个索引的数据量大概有多少？每个索引大概有多少个分片？")])],1)]),t._v(" "),r("h2",{attrs:{id:"缓存"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#缓存"}},[t._v("#")]),t._v(" 缓存")]),t._v(" "),r("ul",[r("li",[r("RouterLink",{attrs:{to:"/02.后端/high-concurrency/why-cache.html"}},[t._v("在项目中缓存是如何使用的？缓存如果使用不当会造成什么后果？")])],1),t._v(" "),r("li",[r("RouterLink",{attrs:{to:"/02.后端/high-concurrency/redis-single-thread-model.html"}},[t._v("Redis 和 Memcached 有什么区别？Redis 的线程模型是什么？为什么单线程的 Redis 比多线程的 Memcached 效率要高得多？")])],1),t._v(" "),r("li",[r("RouterLink",{attrs:{to:"/02.后端/high-concurrency/redis-data-types.html"}},[t._v("Redis 都有哪些数据类型？分别在哪些场景下使用比较合适？")])],1),t._v(" "),r("li",[r("RouterLink",{attrs:{to:"/02.后端/high-concurrency/redis-expiration-policies-and-lru.html"}},[t._v("Redis 的过期策略都有哪些？手写一下 LRU 代码实现？")])],1),t._v(" "),r("li",[r("RouterLink",{attrs:{to:"/02.后端/high-concurrency/how-to-ensure-high-concurrency-and-high-availability-of-redis.html"}},[t._v("如何保证 Redis 高并发、高可用？Redis 的主从复制原理能介绍一下么？Redis 的哨兵原理能介绍一下么？")])],1),t._v(" "),r("li",[r("RouterLink",{attrs:{to:"/02.后端/high-concurrency/redis-persistence.html"}},[t._v("Redis 的持久化有哪几种方式？不同的持久化机制都有什么优缺点？持久化机制具体底层是如何实现的？")])],1),t._v(" "),r("li",[r("RouterLink",{attrs:{to:"/02.后端/high-concurrency/redis-cluster.html"}},[t._v("Redis 集群模式的工作原理能说一下么？在集群模式下，Redis 的 key 是如何寻址的？分布式寻址都有哪些算法？了解一致性 hash 算法吗？如何动态增加和删除一个节点？")])],1),t._v(" "),r("li",[r("RouterLink",{attrs:{to:"/02.后端/high-concurrency/redis-caching-avalanche-and-caching-penetration.html"}},[t._v("了解什么是 redis 的雪崩、穿透和击穿？Redis 崩溃之后会怎么样？系统该如何应对这种情况？如何处理 Redis 的穿透？")])],1),t._v(" "),r("li",[r("RouterLink",{attrs:{to:"/02.后端/high-concurrency/redis-consistence.html"}},[t._v("如何保证缓存与数据库的双写一致性？")])],1),t._v(" "),r("li",[r("RouterLink",{attrs:{to:"/02.后端/high-concurrency/redis-cas.html"}},[t._v("Redis 的并发竞争问题是什么？如何解决这个问题？了解 Redis 事务的 CAS 方案吗？")])],1),t._v(" "),r("li",[r("RouterLink",{attrs:{to:"/02.后端/high-concurrency/redis-production-environment.html"}},[t._v("生产环境中的 Redis 是怎么部署的？")])],1),t._v(" "),r("li",[r("RouterLink",{attrs:{to:"/02.后端/high-concurrency/redis-rehash.html"}},[t._v("有了解过 Redis rehash 的过程吗？")])],1)]),t._v(" "),r("h2",{attrs:{id:"分库分表"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分库分表"}},[t._v("#")]),t._v(" 分库分表")]),t._v(" "),r("ul",[r("li",[r("RouterLink",{attrs:{to:"/02.后端/high-concurrency/database-shard.html"}},[t._v("为什么要分库分表（设计高并发系统的时候，数据库层面该如何设计）？用过哪些分库分表中间件？不同的分库分表中间件都有什么优点和缺点？你们具体是如何对数据库如何进行垂直拆分或水平拆分的？")])],1),t._v(" "),r("li",[r("RouterLink",{attrs:{to:"/02.后端/high-concurrency/database-shard-method.html"}},[t._v("现在有一个未分库分表的系统，未来要分库分表，如何设计才可以让系统从未分库分表动态切换到分库分表上？")])],1),t._v(" "),r("li",[r("RouterLink",{attrs:{to:"/02.后端/high-concurrency/database-shard-dynamic-expand.html"}},[t._v("如何设计可以动态扩容缩容的分库分表方案？")])],1),t._v(" "),r("li",[r("RouterLink",{attrs:{to:"/02.后端/high-concurrency/database-shard-global-id-generate.html"}},[t._v("分库分表之后，id 主键如何处理？")])],1)]),t._v(" "),r("h2",{attrs:{id:"读写分离"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#读写分离"}},[t._v("#")]),t._v(" 读写分离")]),t._v(" "),r("ul",[r("li",[r("RouterLink",{attrs:{to:"/02.后端/high-concurrency/mysql-read-write-separation.html"}},[t._v("如何实现 MySQL 的读写分离？MySQL 主从复制原理是啥？如何解决 MySQL 主从同步的延时问题？")])],1)]),t._v(" "),r("h2",{attrs:{id:"高并发系统"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#高并发系统"}},[t._v("#")]),t._v(" 高并发系统")]),t._v(" "),r("ul",[r("li",[r("RouterLink",{attrs:{to:"/02.后端/high-concurrency/high-concurrency-design.html"}},[t._v("如何设计一个高并发系统？")])],1)]),t._v(" "),r("hr")])}),[],!1,null,null,null);r.default=h.exports}}]);